<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Realistic Scene with Shadows and Camera Controls</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();

        // Load textures
        const sandTexture = textureLoader.load('sand.jpg', function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10); // Adjust the repeat values to scale the texture
        });
        const soilTexture = textureLoader.load('soil.jpg');
        const trunkTexture = textureLoader.load('trunk.jpg');
        // Remove rock texture loading

        // Ground (Sand part)
        const sandGeometry = new THREE.BoxGeometry(7, 0.1, 7); // Thinner sand layer
        const sandMaterial = new THREE.MeshStandardMaterial({ map: sandTexture });
        const sand = new THREE.Mesh(sandGeometry, sandMaterial);
        sand.position.y = -0.05; // Adjust position to sit on top of soil
        sand.receiveShadow = true;
        scene.add(sand);

        // Ground (Soil part)
        const soilGeometry = new THREE.BoxGeometry(7, 0.65, 7); // Increased height for soil
        const soilMaterial = new THREE.MeshStandardMaterial({ map: soilTexture });
        const soil = new THREE.Mesh(soilGeometry, soilMaterial);
        soil.position.y = -0.425; // Adjust position to be below sand
        soil.receiveShadow = true;
        scene.add(soil);

        // Function to create a realistic tree
        function createTree(positionX, positionZ) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 32); // Shorter trunk
            const trunkMaterial = new THREE.MeshStandardMaterial({ map: trunkTexture });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.6; // Adjust position to match new height
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leafGeometry = new THREE.ConeGeometry(0.6, 1, 32);
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x004828 }); // Updated leaf color

            for (let i = 0; i < 3; i++) {
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.y = 1.2 + i * 0.4; // Adjusted position to make the leaves closer together
                leaf.scale.set(1 - i * 0.2, 1 - i * 0.2, 1 - i * 0.2);
                leaf.castShadow = true;
                treeGroup.add(leaf);
            }

            treeGroup.position.set(positionX, 0, positionZ);
            scene.add(treeGroup);
        }

        // Function to create a realistic rock
        function createRock(positionX, positionZ, scale) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.25 * scale, 0); // Reduced scale by 50%
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x4e4a46 }); // Updated rock color
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(positionX, 0.125 * scale, positionZ); // Adjusted position to match new scale
            rock.scale.set(scale, scale, scale);
            rock.castShadow = true;
            scene.add(rock);
        }

        // Creating trees
        createTree(-0.7, 2.1); // Adjust positions
        createTree(1, 0); // Adjust positions

        // Creating rocks
        createRock(-0.8, 0.5, 1.5); // Adjust positions
        createRock(0.7, 1, 0.8); // Adjust positions

        // Adding lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // soft white light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        // Camera positioning
        camera.position.set(0, 3, 5);
        camera.lookAt(0, 0, 0);

        // Controls
        let keys = {};
        window.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Function to update camera movement based on keyboard input
        function updateCameraMovement() {
            const moveSpeed = 0.1;
            const shiftSpeed = 0.05;
            if (keys['w']) {
                camera.position.z -= moveSpeed;
            }
            if (keys['s']) {
                camera.position.z += moveSpeed;
            }
            if (keys['a']) {
                camera.position.x -= moveSpeed;
            }
            if (keys['d']) {
                camera.position.x += moveSpeed;
            }
            if (keys['Shift']) {
                camera.position.y -= shiftSpeed;
            }
            if (keys[' ']) {
                camera.position.y += shiftSpeed;
            }
        }

        // Function to update camera rotation based on arrow keys
        function updateCameraRotationArrowKeys() {
            const rotateSpeed = 0.01;
            if (keys['ArrowLeft']) {
                camera.rotation.y += rotateSpeed;
            }
            if (keys['ArrowRight']) {
                camera.rotation.y -= rotateSpeed;
            }
            if (keys['ArrowUp']) {
                camera.rotation.x += rotateSpeed;
            }
            if (keys['ArrowDown']) {
                camera.rotation.x -= rotateSpeed;
            }
        }

        // Rendering function
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            updateCameraRotationArrowKeys();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
