<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Realistic Scene with Shadows and Camera Controls</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Ground
        const groundGeometry = new THREE.BoxGeometry(7, 0.75, 7);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xC2B280 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.position.y = -0.35; // Adjust position
        ground.receiveShadow = true;
        scene.add(ground);

        // Function to create a realistic tree
        function createTree(positionX, positionZ) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leafGeometry = new THREE.ConeGeometry(0.6, 1, 32);
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00 });

            for (let i = 0; i < 3; i++) {
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.y = 1 + i * 0.6;
                leaf.scale.set(1 - i * 0.2, 1 - i * 0.2, 1 - i * 0.2);
                leaf.castShadow = true;
                treeGroup.add(leaf);
            }

            treeGroup.position.set(positionX, 0, positionZ);
            scene.add(treeGroup);
        }

        // Function to create a realistic rock
        function createRock(positionX, positionZ, scale) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5 * scale, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0xA52A2A });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(positionX, 0.25 * scale, positionZ);
            rock.scale.set(scale, scale, scale);
            rock.castShadow = true;
            scene.add(rock);
        }

        // Creating trees
        createTree(-0.7, 2.1, -2); // Adjust positions
        createTree(1, 0); // Adjust positions

        // Creating rocks
        createRock(-0.8, 0.5, 1.5); // Adjust positions
        createRock(0.7, 1, 0.8); // Adjust positions

        // Adding lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // soft white light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        // Camera positioning
        camera.position.set(0, 3, 5);
        camera.lookAt(0, 0, 0);

        // Controls
        let keys = {};
        window.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Function to update camera movement based on keyboard input
        function updateCameraMovement() {
            const moveSpeed = 0.1;
            const shiftSpeed = 0.05;
            if (keys['w']) {
                camera.position.z -= moveSpeed;
            }
            if (keys['s']) {
                camera.position.z += moveSpeed;
            }
            if (keys['a']) {
                camera.position.x -= moveSpeed;
            }
            if (keys['d']) {
                camera.position.x += moveSpeed;
            }
            if (keys['Shift']) {
                camera.position.y -= shiftSpeed;
            }
            if (keys[' ']) {
                camera.position.y += shiftSpeed;
            }
        }

        // Function to update camera rotation based on arrow keys
        function updateCameraRotationArrowKeys() {
            const rotateSpeed = 0.01;
            if (keys['ArrowLeft']) {
                camera.rotation.y += rotateSpeed;
            }
            if (keys['ArrowRight']) {
                camera.rotation.y -= rotateSpeed;
            }
            if (keys['ArrowUp']) {
                camera.rotation.x += rotateSpeed;
            }
            if (keys['ArrowDown']) {
                camera.rotation.x -= rotateSpeed;
            }
        }

        // Rendering function
        function animate() {
            requestAnimationFrame(animate);
            updateCameraMovement();
            updateCameraRotationArrowKeys();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
